# Pretty Printer for Tiger

In the last assignment, you designed a syntax highlighter for
Tiger. Now the task is to design a pretty printer (which also intends
the program) for better reading. For inspiration read about the
program `intend` that does something similar for C programs. Although
this could be done in multiple ways, my suggestion would be the following.

1. Design the abstract syntax tree for the language.

2. Write a function which on input an abstract syntax tree, prints out
   the pretty program.

3. Write a [`ml-yacc`] program to parse the language. For the lexer
   you can modify the lexer that you wrote in the last assignment
   appropriately.

## Some suggestions.

1. Grow the language slowly. Make a basic Ast type for the language
   may be with only the expressions and consider the pretty printing
   function only for that. Add more and more features to ast and thereby
   improving your language.

2. Reuse the lexer that you have wrote in the past
   assignment. However, you need to make a few changes. Previously,
   you wrote the `Token` type by hand as a SML `datatype`. Now you
   will use the `%term` and `%nonterm` constructs in your `.grm`
   (input to [`ml-yacc`][ml-yacc]) files. The token type is generated
   by [`ml-yacc`] for you.

3. Previously, you were directly calling the lexer function generated
   by [`ml-lex`]. However, now you will be calling the parser function
   rather than the lexer function. In turn, you should set up code
   such that the parser function calls the lexer function. Please read
   the sections ["The lexical analyser"][lex-analyser], ["Creating
   Parser"][create] and ["Using parser"][use].

   Why does one have to follow the above method ? The main reason is
   that the lexer generated by `ml-lex` and the parser generated by
   `ml-yacc` need to depend on each other. Obviously, the parser has
   to depend on the lexer because it calls the lexer for reading in
   the tokens. The lexer in turn needs to know the type of the
   terminals of the grammar are which we would like in the `.grm` file
   (using the %term declaration). The way around this recursion is the
   following.

   1. The `ml-yacc` creates an SML signature `TOKEN` and structure
	  `Token` of signature `TOKEN` (i.e. `Token : TOKEN`) which
	  captures things like the terminals etc of the grammar.
   2. Using the `%header` declartion in the `.lex` file we create the
	  lexer as the body of a SML `functor` which takes as input a
	  structure Token of signature `TOKEN` and gives the lexer structure.

   3. The actual parsing takes a lexer structure, built using the
      functor built in step 2 applied to the `Token` structure and uses it.

   The job of the user is to make these functor and structure
   calls. See the lines 7,8 and 9 of the file
   <../reverse-polish/ec.sml>. The details of the various signatures
   generated by [`ml-yacc`] is available in the section
   ["Signatures"][signatures] of the manual.

## References for syntax of Tiger

1. Appendix of [Appel's book][modern]
2. An [online variant][syntax-tiger-online]


[modern]: <https://www.cs.princeton.edu/~appel/modern/ml/>
[sgr]: <https://en.wikipedia.org/wiki/ANSI_escape_code#SGR_(Select_Graphic_Rendition)_parameters>
[ansi-codes]: <https://en.wikipedia.org/wiki/ANSI_escape_code>
[syntax-tiger-online]: <https://www.lrde.epita.fr/~tiger/tiger.html>
[ml-yacc]:<http://www.smlnj.org/doc/ML-Yacc/>
[ml-lex]: <http://www.smlnj.org/doc/ML-Lex/manual.html>
[lex-analyser]:<http://www.smlnj.org/doc/ML-Yacc/mlyacc004.html>
[create]:<http://www.smlnj.org/doc/ML-Yacc/mlyacc005.html>
[use]:<http://www.smlnj.org/doc/ML-Yacc/mlyacc006.html>
[signatures]:<http://www.smlnj.org/doc/ML-Yacc/mlyacc008.html>
